#!/usr/bin/python -tt
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from __future__ import print_function

import argparse
from lxml import etree as ET
import sys

# Rule result attributes to be compared for equality
rule_attrs_to_compare = ["result", "solution", "stdout", "stderr"]


def parse_cli_opts():
    parser = argparse.ArgumentParser(
        description="preupg-diff takes two Preupgrade Assistant XML reports,"
        " from which the first has been already analyzed by somebody, and the"
        " second hasn't been yet. preupg-diff helps to focus only on the new"
        " issues that emerged in the second XML - it outputs an XML with"
        " only those results that are new or different from the analyzed XML.")
    parser.add_argument("first_xml", help="XML report with analyzed issues")
    parser.add_argument("second_xml", help="New XML report with possibly"
                                           " new issues")
    return parser.parse_args()


class ResultXML(object):
    def __init__(self, xml_path):
        self.root = get_xml_tree_object(xml_path).getroot()
        self.get_rules()

    def get_rules(self):
        """This method finds all the rules that has been used during the
        system preassessment and saves the following information:
        - solution .. solution/remediation text
        - result .. result string, e.g. informational
        - stdout .. optional element holding standard output
        - stderr .. optional element holding standard error output
        """
        self.rules = {}
        self.get_rule_ids_and_solutions()
        self.get_results_and_outputs()

    def get_rule_ids_and_solutions(self):
        for rule_tag in find_subtags_recursive(self.root, "Rule"):
            rule = {}
            rule["solution"] = find_first_subtag(rule_tag, "fixtext").text
            self.rules[rule_tag.attrib["id"]] = rule

    def get_results_and_outputs(self):
        for result_tag in find_subtags_recursive(self.root, "rule-result"):
            rule_id = result_tag.attrib["idref"]
            result_text = find_first_subtag(result_tag, "result").text
            self.rules[rule_id]["result"] = result_text
            self.get_stdout_stderr(rule_id, result_tag)

    def get_stdout_stderr(self, rule_id, result_tag):
        for output_tag in find_subtags_recursive(result_tag, "check-import"):
            output_type = output_tag.attrib["import-name"]
            self.rules[rule_id][output_type] = output_tag.text


"""-----------------XML UTILS-----------------"""


def get_xml_tree_object(xml_path):
    try:
        return ET.parse(xml_path)
    except OSError:
        sys.exit("Error: Failed to read XML '%s'" % xml_path)


def find_subtags_recursive(tag_obj, tag_name):
    """Returns tags with the specific name within the whole XML."""
    tag_name_with_ns = get_tag_with_ns(tag_name)
    return tag_obj.getiterator(tag_name_with_ns)


def find_first_subtag(tag_obj, tag_name):
    tag_name_with_ns = get_tag_with_ns(tag_name)
    return tag_obj.find(tag_name_with_ns)


def get_tag_with_ns(tag_name):
    """All the tags in Preupgrade Assistant result XML are prepended with ns0
    namespace, which is required by python XML parsing modules when
    looking for a tag. This function returns a tag name prepended by this
    namespace and the return value can be used directly for tag searches.
    """
    ns0 = "http://checklists.nist.gov/xccdf/1.2"
    return "{%s}%s" % (ns0, tag_name)


"""-----------------END XML UTILS-----------------"""


def get_rules_w_the_same_result(first_xml_rules, second_xml_rules):
    same_result_rules = {}
    for key in second_xml_rules.keys():
        if key not in first_xml_rules:
            continue
        # Save those new XML rules that have the same result as in the old XML
        if are_results_the_same(first_xml_rules[key], second_xml_rules[key]):
            same_result_rules[key] = second_xml_rules[key]

    return same_result_rules


def are_results_the_same(first_xml_rule_attrs, second_xml_rule_attrs):
    for key in rule_attrs_to_compare:
        if key not in first_xml_rule_attrs or key not in second_xml_rule_attrs:
            continue
        if first_xml_rule_attrs[key] != second_xml_rule_attrs[key]:
            return False
    return True


def remove_same_result_rules(same_result_rules):
    for rule in same_result_rules.keys():
        print(rule)
        # print(same_result_rules[rule]["rule_tag_obj"].getparent().tag)
        # print(same_result_rules[rule]["result_tag_obj"].getparent().tag)


def print_difference_status(second_xml_rules, same_result_rules):
    num_new_rules = len(second_xml_rules.keys())
    num_same_rules = len(same_result_rules.keys())
    if num_same_rules:
        if num_same_rules == num_new_rules:
            print("Every rule from the second XML has exactly the same"
                  " result as in the first XML.")
        else:
            print("Removed %d rules (out of %d) from the second XML.\nThese"
                  " removed rules have exactly the same result in both XMLs."
                  % (num_same_rules, num_new_rules))
    else:
        print("All the rules have different results.")


def main():
    parsed_opts = parse_cli_opts()
    first_xml = ResultXML(parsed_opts.first_xml)
    second_xml = ResultXML(parsed_opts.second_xml)
    same_result_rules = get_rules_w_the_same_result(first_xml.rules,
                                                    second_xml.rules)

    remove_same_result_rules(same_result_rules)
    print_difference_status(second_xml.rules, same_result_rules)


if __name__ == "__main__":
    main()
