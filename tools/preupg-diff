#!/usr/bin/python -tt
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from __future__ import print_function

import argparse
from lxml import etree as ET
import sys

# Rule result attributes to be compared for equality
rule_attrs_to_compare = ["result", "solution", "stdout", "stderr"]


def parse_cli_opts():
    parser = argparse.ArgumentParser(
        description="preupg-diff takes two Preupgrade Assistant XML reports,"
        " from which the first has been already analyzed by somebody, and the"
        " second hasn't been yet. preupg-diff helps to focus only on the new"
        " issues that emerged in the second XML - it outputs an XML with"
        " only those results that are new or different from the analyzed XML.")
    parser.add_argument("first_xml", help="XML report with analyzed issues")
    parser.add_argument("second_xml", help="New XML report with possibly"
                                           " new issues")
    return parser.parse_args()


def get_tag_with_ns(tag_name):
    """All the tags in Preupgrade Assistant result XML are prepended with ns0
    namespace, which is required by python XML parsing modules when
    looking for a tag. This function returns a tag name prepended by this
    namespace and the return value can be used directly for tag searches.
    """
    ns0 = "http://checklists.nist.gov/xccdf/1.2"
    return "{%s}%s" % (ns0, tag_name)


def get_tag_without_ns(tag_with_ns):
    """Remove namespace prepending the actual tag name and return the tag
    name only."""
    if '}' in tag_with_ns:
        return tag_with_ns.split('}', 1)[1]
    else:
        return tag_with_ns


class ResultXML(object):
    def __init__(self, xml_path):
        tree = self.get_xml_tree_object(xml_path)
        self.root = tree.getroot()
        self.rules = self.get_rules()
        self.get_results()

    @staticmethod
    def get_xml_tree_object(xml_path):
        try:
            return ET.parse(xml_path)
        except OSError:
            sys.exit("Error: Failed to read XML '%s'" % xml_path)

    def get_rules(self):
        rules = {}
        rule_tag_name = get_tag_with_ns("Rule")
        solution_tag_name = get_tag_with_ns("fixtext")
        for rule_tag in self.root.getiterator(rule_tag_name):
            rule = {}
            rule["rule_tag_obj"] = rule_tag
            rule["solution"] = rule_tag.find(solution_tag_name).text
            rules[rule_tag.attrib["id"]] = rule
        return rules

    def get_results(self):
        result_tag_name = get_tag_with_ns("rule-result")
        result_subtag_name = get_tag_with_ns("result")
        output_tag_name = get_tag_with_ns("check-import")
        for result_tag in self.root.getiterator(result_tag_name):
            # Results of a rule are stored on a different place in the XML.
            # It's possible to find the rule result by rule id.
            rule_id = result_tag.attrib["idref"]
            self.rules[rule_id]["result_tag_obj"] = result_tag
            result_text = result_tag.find(result_subtag_name).text
            self.rules[rule_id]["result"] = result_text
            for output_tag in result_tag.getiterator(output_tag_name):
                # Get content of both stdout and stderr
                output_type = output_tag.attrib["import-name"]
                self.rules[rule_id][output_type] = output_tag.text


def get_rules_w_the_same_result(first_xml_rules, second_xml_rules):
    """Dictionary holding the rule results has this structure:
    { <rule ID> : {"rule_tag_obj" : <rule XML tag object>,
                   "result_tag_obj" : <rule result XML tag object>,
                   "result" : <result string, e.g. informational>,
                   "solution" : <solution/remediation text>,
                   "stdout" : <optional element holding standard output>,
                   "stderr" : <optional element holding standard error output>
                  },
      <rule ID> : { ...
    }
    """
    same_result_rules = {}
    for key in second_xml_rules.keys():
        if key not in first_xml_rules:
            continue
        # Save those new XML rules that have the same result as in the old XML
        if are_results_the_same(first_xml_rules[key], second_xml_rules[key]):
            same_result_rules[key] = second_xml_rules[key]

    return same_result_rules


def are_results_the_same(first_xml_rule_attrs, second_xml_rule_attrs):
    for key in rule_attrs_to_compare:
        if key not in first_xml_rule_attrs or key not in second_xml_rule_attrs:
            continue
        if first_xml_rule_attrs[key] != second_xml_rule_attrs[key]:
            return False
    return True


def print_difference_status(second_xml_rules, same_result_rules):
    num_new_rules = len(second_xml_rules.keys())
    num_same_rules = len(same_result_rules.keys())
    if num_same_rules:
        if num_same_rules == num_new_rules:
            print("Every rule from the second XML has exactly the same"
                  " result as in the first XML.")
        else:
            print("Removed %d rules (out of %d) from the second XML.\nThese"
                  " removed rules have exactly the same result in both XMLs."
                  % (num_same_rules, num_new_rules))
    else:
        print("All the rules have different results.")


def main():
    parsed_opts = parse_cli_opts()
    first_xml = ResultXML(parsed_opts.first_xml)
    second_xml = ResultXML(parsed_opts.second_xml)
    same_result_rules = get_rules_w_the_same_result(first_xml.rules,
                                                    second_xml.rules)
    print_difference_status(second_xml.rules, same_result_rules)


if __name__ == "__main__":
    main()
